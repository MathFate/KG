
import java.util.Arrays;

public class Mains {
	public static void main(String[] arg){
		double energy0;
		
		double energy2;
		int n = 1024;
		
		
		double[] time = new double[]{0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001};
		int m = 1000;
		double[] tao = new double[6];
		for (int i =0; i < 6; i++) {
			tao[i] = time[i] / m;
		}
								
		for (int j = 0; j < 6; j++) {
			KG system = new KG();		
			system.getParameter(tao[j], n);	
			system.u[512] = 1;
			energy0 = system.energy();			
			for(int i =0; i <= m; i++ ){			
				system.solveEquation();
			}
			energy2 = system.energy();		
			System.out.println("时间间隔为"+time[j]+"的相对误差： "+(energy2 - energy0) / energy0);
		}		
	}
}

//定义处理一维KG链的动力学演化过程的类
class KG {
	int n;       //假设一维KG链有n个点
	double beta;
	double w;
	double et;   
	double c1;
	double c2;
	double d1;
	double g;
	double tao;  //tao为一次积分步长
	double[] e;  //在位势
	double[] x;  //将数组u和p合并形成的新数组
	double[] u;  //坐标，u[1]到u[n]分别代表n个点的坐标，u[0]和u[n+1]赋值为0，不做考虑
	double[] p;  //动量，p[1]到p[n]分别代表n个点的动量，p[1]赋值为0，不做考虑	
	
	//返回系统的能量
	public double energy() {
		double totalenergy = 0;
		for(int i=0; i<=n; i++){
			totalenergy +=p[i]*p[i]/2+e[i]*u[i]*u[i]/2+beta*Math.pow(u[i], 4)/4 +Math.pow((u[i+1]-u[i]),2)/(2*w);
		}
		return totalenergy;
	}	
	
	//定义实现SABA2C功能的函数
	public void solveEquation() {	
		//对于系统初始态依次使用算子
		operatorLC(-Math.pow(tao, 3) * g/2);
		operatorLA(c1 * tao);
		operatorLB(d1 * tao);
		operatorLA(c2 * tao);
		operatorLB(d1 * tao);
		operatorLA(c1 * tao);
		operatorLC(-Math.pow(tao, 3) * g/2);				
	}
	//将LC算子的功能封装
	public void operatorLA(double t) {
		for(int i = 1; i <= n; i++){
			u[i] += p[i] * t;		
		}
	}
	//将LB算子的功能封装
	public void operatorLB(double t) {
		for(int i = 1; i <= n; i++){
			p[i] += ((u[i-1] + u[i+1] - 2*u[i])/w - u[i]*(e[i]+u[i]*u[i]))*t;
		}
	}	
	//将LC算子的功能封装
	public void operatorLC(double t) { 
		for(int i = 2; i <= n-1; i++){
			p[i] += ( (u[i-1]*(e[i-1]+u[i-1]*u[i-1])-(u[i-2] + u[i] - 2*u[i-1])/w)/w + 
					(2/w+e[i]+3*u[i]*u[i])*((u[i-1] + u[i+1] - 2*u[i])/w - u[i]*(e[i]+u[i]*u[i])) +
					(u[i+1]*(e[i+1]+u[i+1]*u[i+1])-(u[i+2] + u[i] - 2*u[i+1])/w)/w   )*t*2;					
		}
		p[1] += ( (2/w+e[1]+3*u[1]*u[1])*((u[2] - 2*u[1])/w - u[1]*(e[1]+u[1]*u[1])) +
				(u[2]*(e[2]+u[2]*u[2])-(u[3] + u[1] - 2*u[2])/w)/w  )*t*2;
		
		p[n] += ( (u[n-1]*(e[n-1]+u[n-1]*u[n-1])-(u[n-2] + u[n] - 2*u[n-1])/w)/w + 
				(2/w+e[n]+3*u[n]*u[n])*((u[n-1] - 2*u[n])/w - u[n]*(e[n]+u[n]*u[n])) )*t*2;		
	}


	//给参数取值的函数
	public void getParameter(double tao, int n) {
		this.n = n;
		this.tao = tao;
		w = 1;
		c1 = 0.5 * (1 - 1 / Math.sqrt(3));
		c2 = 0.5;
		d1 = 0.5;
		g = (2 - Math.sqrt(3))/24;
		beta = 1;
		
		
		e = new double[n + 1];
		x = new double[2 * n + 3];
		u = new double[n + 2];  //下标 1到n表示坐标，其余归零
		p = new double[n + 1];  //下标1到n表示动量，其余归零
		
		//在中间部分生成周期性在位势e
		for(int i = 400; i <= 600; i++){
			if(i % 11 ==0) e[i] = 0.5;
			else e[i] = e[i - 1] + 0.1;
		}		
	}
	
	//打印坐标和动量
	public void printSystem() {
		System.out.println(Arrays.toString(u));
		System.out.println(Arrays.toString(p));
		
	}
	/*public void printSigma() {
		
	}*/
}






















	/*
	public double[] fun1(double[] u, int n) {
		double[] tmp = new double[n+1]
		for(int i = 1; i <=n; i++){
			tmp[i] = u[i-1] + u[i+1] - 2*u[i];			
		}
		return tmp;
	}
	public double[] fun2(double[] u, double[] e, int n) {
		double[] tmp = new double[n+1];
		for(int i = 1; i <=n; i++) {
			tmp[i] = e[i] + u[i]*u[i];
		}
		return tmp;
	}
	*/
	
	
	
	/*
	public double[] operatorLA(double[] x, double t, int n){
		for(int i = 1; i <= n; i++) {
			x[i] += x[i + n + 1]*t;
		}
		
		
	}
	public double[] operatorLB(double[] x, double t, double[] e, double w, double n){
		for(int i = 1; i <= n; i++) {
			x[i + n + 1] += (((x[i - 1] + x[i + 1] - 2 * x [i]))/w - x[i] * (e[i] + x[i] * x[i])) * t;s
		}
		
		
	}
	public double[] operatorLC(double[] x, double t, double n){
		for(int i = 2; i <= n; i++) {
			x[i + n + 1] = (x[i - 1] * (e[i - 1] + x[i - 1] * x[i - 1]) - (x[i - 2] + x[i] - 2*x[i - 1]) / w) + 
		(2 / w + e[i] + 3 * x[i] * x[i]) * ((x[i - 1] +x[i + 1] - 2* x[i])/w - x[i] * (e[i] + x[i] * x[i])) +
		
			
		
		
	}
	*/
	
	
	
	
	
	
	
